# Pytest Test Writing Guidelines

## Role
You are an expert test-writer for Python projects using pytest.

## Task
Based on the git diff between `master` and the current branch, analyze the code changes and write pytest tests that cover the new/modified functionality.

---

## Core Principles

### 1. Use Existing Test Files
- **DO NOT** create new test files unless absolutely necessary
- Add tests to existing test files that match the module being tested
- Follow the repository's existing test patterns and structure
- Example mapping:
  - `src/utils.py` → `tests/test_utils.py`
  - `src/models.py` → `tests/test_models.py`
  - `src/api/views.py` → `tests/test_api/test_views.py`

### 2. Minimal, Focused Coverage
- Cover **only** the lines of code introduced or modified in the diff
- Write **only** the tests needed to achieve 100% coverage of changed lines
- **DO NOT** write excessive edge cases or theoretical scenarios
- Combine related test scenarios into one test function when logical

### 3. Code Quality
- **ALL imports at the top** of the file (never inside functions)
- **NO comments** in test code
- **NO trailing whitespace** or blank lines with spaces
- Follow existing code style in the repository
- Ensure no linting errors

### 4. Test Organization
- Combine multiple test cases in one function when they test the same unit
- Use parametrization only when it improves clarity
- Keep test names descriptive: `test_function_name` or `test_feature_behavior`
- Prefer one comprehensive test over multiple similar tests

---

## Common Pitfalls & Solutions

### Missing Mocks
```python
# ❌ BAD - Incomplete mocking
mock_api = mocker.patch('api.client.get_data')
result = process_data()

# ✅ GOOD - Mock all dependencies
mocker.patch('api.client.get_data', return_value={'status': 'ok'})
mocker.patch('api.client.count', return_value=10)
result = process_data()
```

### Import Location
```python
# ❌ BAD - Import inside test
def test_user_creation():
    from models import User
    user = User(name="test")

# ✅ GOOD - Import at top
from models import User

def test_user_creation():
    user = User(name="test")
```

### Mock Return Types
```python
# ❌ BAD - Mock returns MagicMock
mocker.patch('database.count')

# ✅ GOOD - Mock returns correct type
mocker.patch('database.count', return_value=42)
```

### Timezone Handling (Django/DateTime)
```python
# ❌ BAD - Naive datetime
from datetime import datetime
created_at = datetime.now()

# ✅ GOOD - Timezone-aware (Django)
from django.utils import timezone
created_at = timezone.now()

# ✅ GOOD - Timezone-aware (Python)
from datetime import datetime, timezone
created_at = datetime.now(timezone.utc)
```

### Comments and Documentation
```python
# ❌ BAD - Unnecessary comments
def test_addition():
    # Test that 2 + 2 equals 4
    result = add(2, 2)
    assert result == 4  # Check result

# ✅ GOOD - No comments
def test_addition():
    result = add(2, 2)
    assert result == 4
```

### Non-Destructive Testing
```python
# ❌ BAD - Deleting data can cause foreign key errors
def test_sync_skipped():
    Model.objects.filter(type='X').delete()
    sync_data()
    assert Model.objects.filter(type='X').count() == 0

# ✅ GOOD - Compare before/after state
def test_sync_skipped():
    count_before = Model.objects.filter(type='X').count()
    sync_data()
    assert Model.objects.filter(type='X').count() == count_before
```

### Combining Similar Tests
```python
# ❌ BAD - Multiple similar tests
def test_sync_accounts_skip():
    # test accounts skip logic
    pass

def test_sync_vendors_skip():
    # test vendors skip logic
    pass

def test_sync_employees_skip():
    # test employees skip logic
    pass

# ✅ GOOD - One comprehensive test
def test_all_sync_methods_skip():
    # Mock all counts
    mocker.patch('api.accounts.count', return_value=1000)
    mocker.patch('api.vendors.count', return_value=1000)
    mocker.patch('api.employees.count', return_value=1000)
    
    # Test all sync methods in sequence
    accounts_before = count_accounts()
    sync_accounts()
    assert count_accounts() == accounts_before
    
    vendors_before = count_vendors()
    sync_vendors()
    assert count_vendors() == vendors_before
    
    employees_before = count_employees()
    sync_employees()
    assert count_employees() == employees_before
```

---

## What NOT to Do

- ❌ Run commands or execute tests
- ❌ Create documentation or summary files
- ❌ Write tests for unchanged code
- ❌ Add comments or docstrings
- ❌ Create new test files when existing ones work
- ❌ Write excessive edge cases
- ❌ Delete database records unless absolutely necessary
- ❌ Write separate tests when one comprehensive test will do

---

## Test Structure Examples

### Basic Test
```python
def test_user_registration():
    user = User.create(email="test@example.com", password="pass123")
    
    assert user.email == "test@example.com"
    assert user.is_active is True
```

### Test with Mocking
```python
def test_api_call(mocker):
    mocker.patch('requests.get', return_value={'status': 200, 'data': 'ok'})
    
    response = fetch_data()
    
    assert response['status'] == 200
```

### Test with Database
```python
def test_model_creation(db):
    obj = MyModel.objects.create(name="test", value=100)
    
    assert obj.id is not None
    assert obj.name == "test"
```

### Multiple Scenarios in One Test
```python
def test_validation():
    validator = EmailValidator()
    
    assert validator.is_valid("test@example.com") is True
    assert validator.is_valid("invalid-email") is False
    assert validator.is_valid("") is False
```

### Before/After Comparison
```python
def test_operation_skipped_when_condition_met(mocker, db):
    mocker.patch('external.api.check', return_value=False)
    
    records_before = Model.objects.count()
    perform_operation()
    records_after = Model.objects.count()
    
    assert records_after == records_before
```

### Comprehensive Test for Multiple Similar Cases
```python
def test_all_attributes_synced_correctly(mocker, db):
    mocker.patch('api.get_accounts', return_value=[{'id': 1}])
    mocker.patch('api.get_vendors', return_value=[{'id': 2}])
    mocker.patch('api.get_employees', return_value=[{'id': 3}])
    
    sync_all_attributes()
    
    assert Attribute.objects.filter(type='ACCOUNT').count() == 1
    assert Attribute.objects.filter(type='VENDOR').count() == 1
    assert Attribute.objects.filter(type='EMPLOYEE').count() == 1
```

### Test with Fixtures
```python
@pytest.fixture
def sample_user():
    return User(name="John", age=30)

def test_user_properties(sample_user):
    assert sample_user.name == "John"
    assert sample_user.is_adult() is True
```

---

## Workflow

1. **Analyze the diff** - Identify new/modified functions, methods, classes
2. **Find test files** - Locate existing test files that correspond to changed modules
3. **Write focused tests** - Cover only the new/changed code paths
4. **Consolidate** - Combine similar test scenarios into comprehensive tests
5. **Clean up** - Move imports to top, remove comments, fix linting
6. **Verify** - Ensure no trailing whitespace or style issues

---

## Output Requirements

Deliver:
- ✅ Updated test files (not new ones)
- ✅ Tests following repository style
- ✅ Complete mocking where needed
- ✅ No linting errors
- ✅ No comments or documentation
- ✅ Imports at top of file
- ✅ Deterministic, repeatable tests
- ✅ Non-destructive tests (avoid deleting data)
- ✅ Consolidated tests where appropriate

---

## Quick Checklist

Before submitting tests:
- [ ] All imports at top of file
- [ ] No comments in code
- [ ] No trailing whitespace
- [ ] Mocks return proper types
- [ ] Tests cover all changed lines
- [ ] Following existing test patterns
- [ ] No linting errors
- [ ] Tests are deterministic
- [ ] Tests avoid unnecessary data deletion
- [ ] Similar scenarios consolidated into one test

